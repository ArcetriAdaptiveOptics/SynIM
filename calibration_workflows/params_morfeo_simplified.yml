
# MORFEO: sodium layer, LO 1x1, reference WFS with focus control


main:
  class:             'SimulParams'
  root_dir:          '/raid1/guido/PASSATA/MORFEOtest/'         # Root directory for calibration manager  
  pixel_pupil:       160                    # Linear dimension of pupil phase array
  pixel_pitch:       0.2406               # [m] Pitch of the pupil phase array
  total_time:        2.000                  # [s] Total simulation running time
  time_step:         0.002                  # [s] Simulation time step
  zenithAngleInDeg:  30.0                   # [deg] Airmass correction
  display_server:    false                  # Display server on auto-selected port


seeing:
  class:             'WaveGenerator'
  constant:          0.644                  # ["] seeing value
  outputs: ['output']


wind_speed:
  class:             'WaveGenerator'
  constant:          [5.786, 6.102,  6.838,  7.364,  8.942, 
                      18.41, 30.508, 33.664, 28.404, 23.144,
                      5.786, 8.942,  10.52] # [m/s] Wind speed value
  outputs: ['output']


wind_direction:
  class:             'WaveGenerator'
  constant:          [0,    -180, 0, 0,   90,
                      -180, 90,   0, -90, -90,
                      180,  -90,  90]   # [degrees] Wind direction value
  outputs: ['output']


source_on_axis:
  class:             'Source'
  polar_coordinates:  [0.0, 0.0]           # [arcsec, degrees] source polar coordinates
  magnitude:         8                    # source magnitude
  wavelengthInNm:    750                   # [nm] wavelength

source_lgs1: &LGS_SOURCE
  class:             'Source'
  polar_coordinates:  [45.0, 30.0]           # [arcsec, degrees] source polar coordinates
  height:            90000                 # Source height [m]
  magnitude:         5.0                   # source magnitude
  wavelengthInNm:    589                   # [nm] wavelength

source_lgs2: { <<: *LGS_SOURCE, polar_coordinates: [45.0, 90.0] }
source_lgs3: { <<: *LGS_SOURCE, polar_coordinates: [45.0, 150.0] }
source_lgs4: { <<: *LGS_SOURCE, polar_coordinates: [45.0, 210.0] }
source_lgs5: { <<: *LGS_SOURCE, polar_coordinates: [45.0, 270.0] }
source_lgs6: { <<: *LGS_SOURCE, polar_coordinates: [45.0, 330.0] }

source_ngs1: &NGS_SOURCE
  class:             'Source'
  polar_coordinates:  [55.0,0.0]         # [arcsec, degrees] source polar coordinates
  height:            .inf                # Source height [m]
  magnitude:         10.0                # source magnitude
  wavelengthInNm:    1650                # [nm] wavelength

source_ngs2: { <<: *NGS_SOURCE, polar_coordinates: [55.0,120.0] }
source_ngs3: { <<: *NGS_SOURCE, polar_coordinates: [55.0,240.0] }

source_ref1: &REF_SOURCE
  class:             'Source'
  polar_coordinates:  [55.0,0.0]         # [arcsec, degrees] source polar coordinates
  height:            .inf                # Source height [m]
  magnitude:         12.0                # source magnitude
  wavelengthInNm:    750                # [nm] wavelength

source_ref2: { <<: *REF_SOURCE, polar_coordinates: [55.0,120.0] }
source_ref3: { <<: *REF_SOURCE, polar_coordinates: [55.0,240.0] }

pupilstop:                                 # Default parameters (circular pupil)
  class: 'Pupilstop'
  tag: 'mask_160px_6petals'

atmo:
  class:                'AtmoEvolution'
  simul_params_ref:  'main'
  L0:                   25                   # [m] Outer scale
  heights:              [30,    250,   1000, 2000,  3000,
                         5000,  7000,  9000, 12000, 15000,
                         18000, 21000, 24000] # [m] layer heights at 0 zenith angle
  Cn2:                  [0.361931, 0.345035, 0.0398925, 0.0323939, 0.0422920,
                         0.0259951, 0.0219958, 0.0310041, 0.0489008, 0.0351334,
                         0.00863836, 0.00431918, 0.00246853] # Cn2 weights (total must be eq 1)
  fov:      160
  inputs:
    seeing: 'seeing.output'
    wind_speed: 'wind_speed.output'
    wind_direction: 'wind_direction.output'
  outputs: ['layer_list']


prop:
  class:                'AtmoPropagation'
  simul_params_ref:  'main'
  source_dict_ref:      ['source_on_axis',
                         'source_lgs1','source_lgs2','source_lgs3','source_lgs4','source_lgs5','source_lgs6',
                         'source_ngs1', 'source_ngs2', 'source_ngs3',
                         'source_ref1', 'source_ref2', 'source_ref3']
  inputs:
    atmo_layer_list: ['atmo.layer_list']
    common_layer_list: [ 'pupilstop',
                  'dm1.out_layer:-1',
                  'dm2.out_layer:-1',
                  'dm3.out_layer:-1',
  #               'dm_disturb.out_layer'
                  ]
  outputs: ['out_source_on_axis_ef',
            'out_source_lgs1_ef', 'out_source_lgs2_ef', 'out_source_lgs3_ef',
            'out_source_lgs4_ef', 'out_source_lgs5_ef', 'out_source_lgs6_ef',
            'out_source_ngs1_ef', 'out_source_ngs2_ef', 'out_source_ngs3_ef',
            'out_source_ref1_ef', 'out_source_ref2_ef', 'out_source_ref3_ef']            

# ---------------------------------------
# LGS WFS simulation and slope processing
# ---------------------------------------

launcher:
  class:             'LaserLaunchTelescope'
  simul_params_ref:  'main'
  spot_size:          1.8


sh_lgs1: &LGS_SH
  class:             'SH'
  subap_wanted_fov:  6.9                     # Requested field-of-view [arcsec]
  sensor_pxscale:    1.15                    # Pixel scale in arcsec/pix
  subap_npx:         6                       # Output sampling [usually corresponding to CCD pixels]
  subap_on_diameter: 40                      # Number of subapertures in diameter
  wavelengthInNm:    589                     # [nm] Pyramid wavelength
  fov_ovs_coeff:     1.52                    # Force phase interpolation to a multiple of 40
  rotAnglePhInDeg:   6.2
  laser_launch_tel_ref: 'launcher'
  inputs:
    in_ef: 'prop.out_source_lgs1_ef'
  outputs:  ['out_i']

sh_lgs2: { <<: *LGS_SH, rotAnglePhInDeg: 14.2, inputs: {in_ef: 'prop.out_source_lgs2_ef'}}
sh_lgs3: { <<: *LGS_SH, rotAnglePhInDeg: -6.2, inputs: {in_ef: 'prop.out_source_lgs3_ef'}}
sh_lgs4: { <<: *LGS_SH, rotAnglePhInDeg:  6.2, inputs: {in_ef: 'prop.out_source_lgs4_ef'}}
sh_lgs5: { <<: *LGS_SH, rotAnglePhInDeg: 14.2, inputs: {in_ef: 'prop.out_source_lgs5_ef'}}
sh_lgs6: { <<: *LGS_SH, rotAnglePhInDeg: -6.2, inputs: {in_ef: 'prop.out_source_lgs6_ef'}}

detector_lgs1: &LGS_DETECTOR
  class:             'CCD'
  simul_params_ref:  'main'
  size:              [240,240]               # Detector size in pixels
  dt:                0.002                   # [s] Detector integration time
  bandw:             20                      # [nm] Sensor bandwidth
  photon_noise:      True                    # activate photon noise
  readout_noise:     True                    # activate readout noise
  readout_level:     2.7                     # readout noise in [e-/pix/frame]
  quantum_eff:       0.188                   # quantum efficiency * total transmission
  inputs:
    in_i: 'sh_lgs1.out_i'
  outputs:  ['out_pixels']

detector_lgs2: { <<: *LGS_DETECTOR, inputs: {in_i: 'sh_lgs2.out_i' }}
detector_lgs3: { <<: *LGS_DETECTOR, inputs: {in_i: 'sh_lgs3.out_i' }}
detector_lgs4: { <<: *LGS_DETECTOR, inputs: {in_i: 'sh_lgs4.out_i' }}
detector_lgs5: { <<: *LGS_DETECTOR, inputs: {in_i: 'sh_lgs5.out_i' }}
detector_lgs6: { <<: *LGS_DETECTOR, inputs: {in_i: 'sh_lgs6.out_i' }}

slopec_lgs1: &LGS_SLOPEC
  class:             'ShSlopec'
  weight_int_pixel_dt: 0.2
  window_int_pixel:    True
  subapdata_object:  'PLACEHOLDER_SUBAP_LGS1'  # Will be updated in step 1
  filtmat_data:      'PLACEHOLDER_FILTMAT_LGS1'  # Will be updated in step 3
  inputs:
    in_pixels:        'detector_lgs1.out_pixels'
  outputs:  ['out_slopes', 'out_subapdata']

slopec_lgs2: { <<: *LGS_SLOPEC,
    inputs: {in_pixels: 'detector_lgs2.out_pixels' },
  subapdata_object:  'PLACEHOLDER_SUBAP_LGS2',  # Will be updated in step 1
  filtmat_data:      'PLACEHOLDER_FILTMAT_LGS2'  # Will be updated in step 3
    }

slopec_lgs3: { <<: *LGS_SLOPEC,
    inputs: {in_pixels: 'detector_lgs3.out_pixels' },
  subapdata_object:  'PLACEHOLDER_SUBAP_LGS3',  # Will be updated in step 1
  filtmat_data:      'PLACEHOLDER_FILTMAT_LGS3'  # Will be updated in step 3
    }

slopec_lgs4: { <<: *LGS_SLOPEC,
    inputs: {in_pixels: 'detector_lgs4.out_pixels' },
    subapdata_object:  'PLACEHOLDER_SUBAP_LGS4',  # Will be updated in step 1
    filtmat_data:      'PLACEHOLDER_FILTMAT_LGS4'  # Will be updated in step 3
    }
slopec_lgs5: { <<: *LGS_SLOPEC,
    inputs: {in_pixels: 'detector_lgs5.out_pixels' },
    subapdata_object:  'PLACEHOLDER_SUBAP_LGS5',  # Will be updated in step 1
    filtmat_data:      'PLACEHOLDER_FILTMAT_LGS5'  # Will be updated in step 3
    }

slopec_lgs6: { <<: *LGS_SLOPEC,
    inputs: {in_pixels: 'detector_lgs6.out_pixels' },
    subapdata_object:  'PLACEHOLDER_SUBAP_LGS6',  # Will be updated in step 1
    filtmat_data:      'PLACEHOLDER_FILTMAT_LGS6'  # Will be updated in step 3
    }

# ---------------------------------------
# LO WFS simulation and slope processing
# ---------------------------------------

sh_ngs1: &NGS_SH
  class:             'SH'
  subap_on_diameter: 1                      # Number of subapertures in diameter
  subap_wanted_fov:  1.8                    # Requested field-of-view [arcsec]
  sensor_pxscale:    0.0075                 # Pixel scale in arcsec/pix
  subap_npx:         240                    # Output sampling [usually corresponding to CCD pixels]
  wavelengthInNm:    1650                   # [nm] Pyramid wavelength
  inputs:
    in_ef: 'prop.out_source_ngs1_ef'
  outputs:  ['out_i']

sh_ngs2: { <<: *NGS_SH, inputs: {in_ef: 'prop.out_source_ngs2_ef' }}
sh_ngs3: { <<: *NGS_SH, inputs: {in_ef: 'prop.out_source_ngs3_ef' }}

detector_ngs1: &NGS_DETECTOR
  class:             'CCD'
  simul_params_ref:  'main'
  size:              [240,240]               # Detector size in pixels
  dt:                0.002                   # [s] Detector integration time
  bandw:             330                      # [nm] Sensor bandwidth
  photon_noise:      True                    # activate photon noise
  readout_noise:     True                    # activate readout noise
  excess_noise:      True                    # activate excess noise
  excess_delta:      3.33
  readout_level:     1.0                     # readout noise in [e-/pix/frame]
  quantum_eff:       0.382                   # quantum efficiency * total transmission
  inputs:
    in_i: 'sh_ngs1.out_i'
  outputs:  ['out_pixels']

detector_ngs2: { <<: *NGS_DETECTOR, inputs: {in_i: 'sh_ngs2.out_i' }}
detector_ngs3: { <<: *NGS_DETECTOR, inputs: {in_i: 'sh_ngs3.out_i' }}

slopec_ngs1: &NGS_SLOPEC
  class:             'ShSlopec'
  weightedPixRad:    1
  subapdata_object:  'morfeo_ps160p0.2406_shs1x1_wl1650_fv1.8_np240'
  inputs:
    in_pixels:        'detector_ngs1.out_pixels'
  outputs:  ['out_slopes', 'out_subapdata']

slopec_ngs2: { <<: *NGS_SLOPEC, inputs: {in_pixels: 'detector_ngs2.out_pixels' }}
slopec_ngs3: { <<: *NGS_SLOPEC, inputs: {in_pixels: 'detector_ngs3.out_pixels' }}

# ---------------------------------------
# REF WFS simulation and slope processing
# ---------------------------------------

sh_ref1: &REF_SH
  class:             'SH'
  subap_on_diameter: 8                       # Number of subapertures in diameter
  subap_wanted_fov:  4.6                     # Requested field-of-view [arcsec]
  sensor_pxscale:    0.153                   # Pixel scale in arcsec/pix
  subap_npx:         30                      # Output sampling [usually corresponding to CCD pixels]
  wavelengthInNm:    750                     # [nm] Pyramid wavelength
  inputs:
    in_ef: 'prop.out_source_ref1_ef'
  outputs:  ['out_i']

sh_ref2: { <<: *REF_SH, inputs: {in_ef: 'prop.out_source_ref2_ef' }}
sh_ref3: { <<: *REF_SH, inputs: {in_ef: 'prop.out_source_ref3_ef' }}

detector_ref1: &REF_DETECTOR
  class:             'CCD'
  simul_params_ref:  'main'
  size:              [240,240]               # Detector size in pixels
  dt:                0.010                   # [s] Detector integration time
  bandw:             400                     # [nm] Sensor bandwidth
  photon_noise:      True                    # activate photon noise
  readout_noise:     True                    # activate readout noise
  excess_noise:      True                    # activate excess noise
  readout_level:     0.2                     # readout noise in [e-/pix/frame]
  quantum_eff:       0.400                   # quantum efficiency * total transmission
  inputs:
    in_i: 'sh_ref1.out_i'
  outputs:  ['out_pixels']

detector_ref2: { <<: *REF_DETECTOR, inputs: {in_i: 'sh_ref2.out_i' }}
detector_ref3: { <<: *REF_DETECTOR, inputs: {in_i: 'sh_ref3.out_i' }}

slopec_ref1: &REF_SLOPEC
  class:             'ShSlopec'
  thr_value:         10
  subapdata_object:  'morfeo_ps160p0.2406_shs8x8_wl750_fv4.6_np30_th0.50'
  inputs:
    in_pixels:        'detector_ref1.out_pixels'
  outputs:  ['out_slopes', 'out_subapdata']

slopec_ref2: { <<: *REF_SLOPEC, inputs: {in_pixels: 'detector_ref2.out_pixels' }}
slopec_ref3: { <<: *REF_SLOPEC, inputs: {in_pixels: 'detector_ref3.out_pixels' }}


# -----------------------------
# LGS pipeline
# -----------------------------

tomo_polc_lgs:
  class:              'Modalrec'
  recmat_object:      'PLACEHOLDER_LGS_RECMAT'  # Will be updated in step 6
  projmat_object:     'PLACEHOLDER_PROJMAT'  # Will be updated in step 8
  intmat_object:      'PLACEHOLDER_LGS_INTMAT'  # Will be updated in step 6
  polc:   true
  input_modes_slice:  [0, 3305] 
  in_commands_size:   3305
  inputs:
    in_slopes_list:        ['slopec_lgs1.out_slopes',
                            'slopec_lgs2.out_slopes',
                            'slopec_lgs3.out_slopes',
                            'slopec_lgs4.out_slopes',
                            'slopec_lgs5.out_slopes',
                            'slopec_lgs6.out_slopes']
    in_commands:            'iir_lgs.out_comm:-1'
  outputs:  ['out_modes', 'out_pseudo_ol_modes']

iir_lgs:
  class:             'Integrator'
  simul_params_ref:  'main'
  int_gain: [0.0,0.25,0.0,0.25]
  n_modes:  [3,2278,3,1021] # 1260 + 1026 - 5 + 1026 - 2
  delay: 1.75
  inputs:
    delta_comm: 'tomo_polc_lgs.out_modes'
  outputs:  ['out_comm']

# ----------------
# LO pipeline
# ----------------

tomo_ngs:
  class:              'Modalrec'
  recmat_object:      'PLACEHOLDER_NGS_RECMAT'  # Will be updated in step 7
  inputs:
    in_slopes_list:        ['slopec_ngs1.out_slopes',
                            'slopec_ngs2.out_slopes',
                            'slopec_ngs3.out_slopes']
  outputs:  ['out_modes', 'out_pseudo_ol_modes']

iir_ngs:
  class:             'Integrator'
  simul_params_ref:  'main'
  int_gain: [0.1,0.1]
  n_modes:  [2,3]
  delay: 1.75
  inputs:
    delta_comm: 'tomo_ngs.out_modes'
  outputs:  ['out_comm']

# --------------
# Focus pipeline
# --------------

rec_focus:
  class:              'Modalrec'
  recmat_object:      'PLACEHOLDER_FOCUS_RECMAT'  # Will be updated in step 5
  inputs:
    in_slopes_list:        ['slopec_ref1.out_slopes',
                            'slopec_ref2.out_slopes',
                            'slopec_ref3.out_slopes']
  outputs:  ['out_modes']

slicer_focus:
  class:          'BaseSlicer'
  slice_args:     [2,3]
  inputs:
    in_value: 'rec_focus.out_modes'
  outputs:  ['out_value']

iir_focus:
  class:             'Integrator'
  simul_params_ref:  'main'
  int_gain:          [0.5]
  n_modes:           [1]
  delay: 1.0
  inputs:
      delta_comm: 'slicer_focus.out_value'     
  outputs:  ['out_comm']

# ----------------
# HO + LO + Focus
# ----------------

modal_combination:
  class:        'LinearCombination'
  simul_params_ref:  'main'
  no_lift: True
  plate_scale_idx: 2281 # 1260+1026-5
  dm1_ref: 'dm1'
  dm3_ref: 'dm3'
  start_modes: [0,0]
  inputs:
    in_vectors_list: ['iir_lgs.out_comm', 'iir_focus.out_comm', 'iir_ngs.out_comm']
  outputs: ['out_vector']

slicer1: &SLICER
  class:          'BaseSlicer'
  slice_args:     [0,1140]
  inputs:
    in_value: 'modal_combination.out_vector'
  outputs:  ['out_value']

slicer2: { <<: *SLICER, slice_args: [1260,2281]} # 1260 + 1026 - 5
slicer3: { <<: *SLICER, slice_args: [2281,3307]} # 1260 + 1026 - 5 + 1026 - 2

# ----------------

dm1:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_DM1'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_DM1'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  height:            600                      # DM height [m]
  inputs:
    in_command: 'slicer1.out_value'
  outputs:  ['out_layer']

dm2:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_DM2'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_DM2'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  start_mode:        5                         # Offset into influence function matrix
  height:            6500                      # DM height [m]
  inputs:
      in_command: 'slicer2.out_value'
  outputs:  ['out_layer']

dm3:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_DM3'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_DM3'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  start_mode:        2                          # Offset into influence function matrix
  height:            17500                      # DM height [m]
  inputs:
    in_command: 'slicer3.out_value'
  outputs:  ['out_layer']

psf:
  class:             'PSF'
  simul_params_ref:  'main'
  wavelengthInNm:    2200                 # [nm] Imaging wavelength
  nd:                4                    # padding coefficient for PSF computation
  start_time:        0.05                 # PSF integration start time
  inputs:
    in_ef:  'prop.out_source_on_axis_ef'
  outputs:  ['out_psf', 'out_sr']

modal_analysis:
  class: 'ModalAnalysis'
  ifunc_inv_object: 'PLACEHOLDER_IFUNC_INV'  # Will be updated in step X
  inputs:
    in_ef: 'prop.out_source_on_axis_ef'
  outputs: ['out_modes']

data_store:
  class:             'DataStore'
  store_dir:         '/raid1/guido/results/MORFEO/specula/'             # Data result directory: 'store_dir'/TN/
  inputs:
    input_list: ['resMod-modal_analysis.out_modes',
                 'deltaCommLgs-tomo_polc_lgs.out_modes',
                 'deltaCommNgs-tomo_ngs.out_modes',
                 'comm1-slicer1.out_value',
                 'comm2-slicer2.out_value',
                 'comm3-slicer3.out_value',
                 'srRes-psf.out_sr']

# modes_disp:
#   class:            'ModesDisplay'
#   inputs:
#     modes:          'modal_analysis.out_modes'
#   title:            'residual modes'
#   xrange:           [0, 100]
#   yrange:           [-200.0, 200.0]

# ph_disp:
#   class:            'PhaseDisplay'
#   inputs:
#     phase:          'prop.out_source_on_axis_ef'
#   title:            'PUPIL PHASE'

# --- --- --- layers / virtual DMs --- --- --- #

layer1:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L1'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L1'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            0                         # DM height [m]

layer2:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L2'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L2'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            2000                      # DM height [m]

layer3:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L3'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L3'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            4500                      # DM height [m]

layer4:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L4'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L4'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            11000                     # DM height [m]

layer5:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L5'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L5'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            15000                     # DM height [m]

layer6:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L6'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L6'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            18000                     # DM height [m]

layer7:
  class:             'DM'
  simul_params_ref:  'main'
  ifunc_object:      'PLACEHOLDER_IFUNC_L7'  # Will be updated in step X
  m2c_object:        'PLACEHOLDER_M2C_L7'  # Will be updated in step X
  nmodes:            Null                # Will be updated in step X
  #start_mode:        3                         # Offset into influence function matrix
  height:            22000                     # DM height [m]

reconstruction:
  sigma2inNm2:  2e4
  noise_elong_model:  false
  naThicknessInM: 10.0
  tGparameter: 0.0

  # Modes to use for NGS reconstruction
  ngs_n_modes_dm:  [2, 0, 3]      # Number of modes per DM for NGS (tip-tilt only)
  ngs_n_modes_layer: []     # Number of modes per layer for NGS (empty = none)

  # Modes to use for REF reconstruction  
  ref_n_modes_dm:  [50, 45, 48]      # Number of modes per DM for REF (focus only)
  ref_n_modes_layer: [50, 50, 50, 50, 50, 50, 50]     # Number of modes per layer for REF (empty = none)

projection:
  reg_factor: 1e-4
  ifunc_inverse_tag: 'PLACEHOLDER_IFUNC_INVERSE'  # Will be updated in step X
  opt_sources:
    polar_coordinates: [[0.0, 0.0],
                  [30.0, 0.0],  [30.0, 90.0],  [30.0, 180.0], [30.0, 270.0],
                  [30.0, 45.0], [30.0, 135.0], [30.0, 225.0], [30.0, 315.0],
                  [80.0, 0.0],  [80.0, 90.0],  [80.0, 180.0], [80.0, 270.0],
                  [80.0, 45.0], [80.0, 135.0], [80.0, 225.0], [80.0, 315.0]]  # [radius, angle] in arcsec, degrees
    weights: [0.5,
              1.0,  1.0,  1.0,  1.0,
              1.0,  1.0,  1.0,  1.0,
              0.05, 0.05, 0.05, 0.05,
              0.05, 0.05, 0.05, 0.05]